---
title: "OmniDaemon"
description: "Universal Event-Driven Runtime Engine for AI Agents"
---

# ğŸŒ OmniDaemon

## Universal Event-Driven Runtime Engine for AI Agents

**Run any AI agent. Any framework. One event-driven control plane.**

*Created by [Abiola Adeshina](https://github.com/Abiorh001) â€¢ From the team behind [OmniCoreAgent](https://github.com/omnirexflora-labs/omnicoreagent)*

---

## ğŸ¯ What is OmniDaemon?

> **"Kubernetes for AI Agents"** - A universal runtime that makes AI agents autonomous, observable, and scalable.

OmniDaemon transforms AI from static reasoning engines into **event-driven, self-operating entities** that integrate seamlessly across clouds, data streams, and enterprise environments.

### In 5 Seconds

- ğŸ¤– **Run AI agents in the background** (not chatbots, not APIs)
- ğŸ“¨ **Event-driven** (agents react to events, not HTTP requests)
- ğŸ”Œ **Use any AI framework** (OmniCore Agent, Google ADK, LangChain, or custom)
- ğŸš€ **Production-ready** (retries, DLQ, metrics, scaling built-in)

---

## ğŸŒŠ Why Event-Driven AI? The Evolution Story

### The AI Evolution: Three Waves

AI has progressed through distinct waves, each unlocking new possibilities but also introducing critical limitations.

#### **Wave 1: Predictive Models (Traditional ML)**

The first wave focused on narrowly defined, domain-specific tasks.

```
Training Data â†’ ML Model â†’ Predictions for Specific Use Case
```

**Limitations:**
- âŒ Domain-specific and rigid
- âŒ Required ML expertise for each use case
- âŒ Difficult to repurpose
- âŒ Lacked scalability

#### **Wave 2: Generative Models (LLMs)**

Generative AI revolutionized capabilities by training on vast, diverse datasets.

```
Massive Dataset â†’ LLM â†’ Generate Text, Images, Code
```

**Breakthrough:** Generalization across contexts

**Limitations:**
- âŒ Fixed in time (no dynamic information)
- âŒ Expensive to fine-tune
- âŒ No access to private/domain data
- âŒ Generic responses without context

**Example Problem:**
> "Recommend an insurance policy tailored to my health history, location, and financial goals."

The LLM can't deliver accurate recommendations because it lacks access to your personal data. Without it, responses are either generic or wrong.

**Solution: Compound AI (RAG)**

Retrieval-Augmented Generation bridges the gap:
1. Retrieve user's health and financial data from database
2. Add data to context during prompt assembly
3. LLM generates accurate, personalized response

```
Database â†’ Retrieve Context â†’ LLM + Context â†’ Accurate Response
```

**RAG Limitation:** Fixed workflows. Every interaction path must be pre-defined. This rigidity makes it impractical for complex, dynamic tasks.

#### **Wave 3: Agentic AI (Current)**

The future of AI lies with **autonomous agents** â€” systems that think, adapt, and act independently.

```
Event â†’ Agent Reasons â†’ Uses Tools â†’ Adapts Workflow â†’ Takes Action
```

**Why Agents Are Different:**
- âœ… **Dynamic workflows** (figure out next steps on the fly)
- âœ… **Context-driven** (adapt to the situation)
- âœ… **Autonomous** (no pre-defined paths needed)
- âœ… **Tool use** (access external systems)
- âœ… **Memory** (learn from past interactions)

**Industry Validation:**

> "Agents are the new apps." â€” **Dharmesh Shah**, HubSpot CTO

> "We've reached the upper limits of what LLMs can do. The future lies with autonomous agents." â€” **Marc Benioff**, Salesforce CEO (The Wall Street Journal, "Future of Everything" podcast)

Google's Gemini and OpenAI's Orion are reportedly hitting limits despite larger training datasets. The next breakthrough isn't bigger models â€” it's **agentic systems**.

---

## ğŸ—ï¸ Why Agents Need Event-Driven Architecture

### The Infrastructure Problem

AI agents aren't just an AI problem â€” they're a **distributed systems problem**.

Agents need:
- ğŸ“Š Access to data from multiple sources
- ğŸ”§ Ability to use tools and external systems
- ğŸ¤ Communication with other agents
- ğŸŒ Outputs available to multiple services
- âš¡ Real-time responsiveness
- ğŸ“ˆ Horizontal scalability

**This isn't about better models. It's about better infrastructure.**

### The Tight Coupling Problem

You *could* connect agents via APIs and RPC, but that creates:

```
âŒ Tightly Coupled Architecture
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Agent 1 â”‚â”€â”€â”€â”€â–¶â”‚ Agent 2 â”‚â”€â”€â”€â”€â–¶â”‚ Agent 3 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     â”‚               â”‚               â”‚
     â–¼               â–¼               â–¼
  [Fails] â”€â”€â”€â”€â”€â”€â”€â–¶ [Fails] â”€â”€â”€â”€â”€â–¶ [Fails]

Problems:
â€¢ If one agent fails, entire chain breaks
â€¢ Hard to scale individual agents
â€¢ Changes ripple through system
â€¢ Difficult to add new agents
â€¢ Can't support multiple consumers
```

### The Event-Driven Solution

Event-Driven Architecture (EDA) solves this through **loose coupling**:

```
âœ… Event-Driven Architecture
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚   Event Bus      â”‚
        â”‚ (Redis Streams)  â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â†‘      â†‘      â†‘
         â”‚      â”‚      â”‚
    â”Œâ”€â”€â”€â”€â”´â”€â”€â” â”Œâ”´â”€â”€â”€â”€â” â”Œâ”´â”€â”€â”€â”€â”
    â”‚Agent 1â”‚ â”‚Agentâ”‚ â”‚Agentâ”‚
    â”‚       â”‚ â”‚  2  â”‚ â”‚  3  â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”˜

Benefits:
âœ… Agents don't depend on each other
âœ… Scale agents independently
âœ… Add/remove agents dynamically
âœ… Multiple consumers per event
âœ… Automatic retries & DLQ
âœ… Message persistence
```

### Agents as Microservices

Like microservices, agents are:
- **Autonomous** - Operate independently
- **Decoupled** - Don't depend on each other
- **Scalable** - Add more instances for load

**But agents go further:**
- **Context-rich** - Need shared information to reason
- **Tool-enabled** - Interact with external systems
- **Collaborative** - Share insights with other agents
- **Adaptive** - Modify behavior based on events

**The Challenge:** Managing these informational dependencies without tight coupling.

**The Solution:** EDA provides a "central nervous system" for data flow.

---

## ğŸš€ What OmniDaemon Provides

### Traditional AI (Request-Driven)
```
User asks â†’ AI responds â†’ Done âŒ
```

### OmniDaemon (Event-Driven)
```
Event happens â†’ AI agent reacts â†’ Result stored âœ…
              â†’ Multiple agents listen
              â†’ Automatic retries
              â†’ DLQ for failures
```

### Core Features

| Feature | What It Means |
|---------|---------------|
| ğŸ¤– **Run Any AI Agent** | OmniCore Agent, Google ADK, LangChain, CrewAI, AutoGen, LlamaIndex, or custom |
| ğŸ“¨ **Event-Driven** | Agents listen to topics, not HTTP endpoints |
| ğŸ”„ **Auto Retries** | Failed tasks retry automatically (configurable) |
| ğŸ’€ **Dead Letter Queue** | Failed messages go to DLQ for analysis |
| ğŸ“Š **Real-time Metrics** | Tasks received, processed, failed, timing |
| ğŸ›ï¸ **Full Control** | Beautiful CLI + HTTP API for management |
| âš–ï¸ **Horizontal Scaling** | Run multiple agent instances for load balancing |
| ğŸ”Œ **Pluggable** | Swap backends via environment variables (no code changes!) |

### Pluggable Architecture

**The Simple Truth:** You provide the URL, OmniDaemon handles EVERYTHING else!

```bash
# Event Bus - Switch backends with NO code changes
EVENT_BUS_TYPE=redis_stream + REDIS_URL=...         # Current
EVENT_BUS_TYPE=rabbitmq + RABBITMQ_URL=...          # Coming soon
EVENT_BUS_TYPE=kafka + KAFKA_SERVERS=...            # Coming soon

# Storage - Switch backends with NO code changes
STORAGE_BACKEND=json + JSON_STORAGE_DIR=...         # Development
STORAGE_BACKEND=redis + REDIS_URL=...               # Production
STORAGE_BACKEND=postgresql + POSTGRES_URL=...       # Coming soon
STORAGE_BACKEND=mongodb + MONGODB_URI=...           # Coming soon
```

**Your agent code NEVER changes. Just update environment variables!**

---

## ğŸ¯ When to Use OmniDaemon

### âœ… Perfect For

- **Background AI Agents** - Autonomous agents that react to events
- **Event-Driven Workflows** - Multi-step AI processing pipelines
- **Multi-Agent Systems** - Multiple agents collaborating on tasks
- **Async AI Processing** - Long-running AI tasks (not real-time chat)
- **Enterprise AI Ops** - Scalable, observable, production AI systems

### âŒ Not Recommended For

- **Simple HTTP APIs** - Use FastAPI/Flask directly (simpler)
- **Real-Time Chat** - Use WebSockets/SSE (lower latency)
- **Synchronous Request-Response** - Use REST APIs (simpler architecture)
- **Single-Shot Scripts** - Use Python scripts directly (no runtime needed)

### ğŸ†š Compared to Alternatives

| Tool | Use Case | vs OmniDaemon |
|------|----------|---------------|
| **Celery** | Task queues | âŒ Not AI-first, complex setup, no agent abstraction |
| **AWS Lambda** | Serverless functions | âŒ Cold starts, time limits, vendor lock-in |
| **Temporal** | Workflow engine | âŒ Heavy, complex, not AI-optimized |
| **Airflow** | DAG orchestration | âŒ Batch-oriented, not real-time events |
| **OmniDaemon** | AI Agent Runtime | âœ… AI-first, event-driven, any framework, production-ready |

---

## ğŸ—ï¸ Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         OmniDaemon                              â”‚
â”‚                   Universal Runtime Engine                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
                              â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚                     â”‚                     â”‚
        â–¼                     â–¼                     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Event Bus   â”‚    â”‚   Storage    â”‚    â”‚ Agent Runner â”‚
â”‚ (Pluggable!) â”‚    â”‚ (Pluggable!) â”‚    â”‚  (Your Code) â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ â€¢ Streams    â”‚    â”‚ â€¢ Agents     â”‚    â”‚ â€¢ Register   â”‚
â”‚ â€¢ Pub/Sub    â”‚    â”‚ â€¢ Results    â”‚    â”‚ â€¢ Subscribe  â”‚
â”‚ â€¢ DLQ        â”‚    â”‚ â€¢ Metrics    â”‚    â”‚ â€¢ Process    â”‚
â”‚ â€¢ Groups     â”‚    â”‚ â€¢ Config     â”‚    â”‚ â€¢ Respond    â”‚
â”‚              â”‚    â”‚              â”‚    â”‚              â”‚
â”‚ Redis âœ…     â”‚    â”‚ Redis âœ…     â”‚    â”‚              â”‚
â”‚ Kafka ğŸš§     â”‚    â”‚ JSON âœ…      â”‚    â”‚              â”‚
â”‚ RabbitMQ ğŸš§  â”‚    â”‚ Postgres ğŸš§  â”‚    â”‚              â”‚
â”‚ NATS ğŸš§      â”‚    â”‚ MongoDB ğŸš§   â”‚    â”‚              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚                     â”‚                     â”‚
        â”‚                     â”‚                     â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
                              â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚                     â”‚                     â”‚
        â–¼                     â–¼                     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚     CLI      â”‚    â”‚     API      â”‚    â”‚     SDK      â”‚
â”‚   (Typer)    â”‚    â”‚  (FastAPI)   â”‚    â”‚  (Python)    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ â€¢ Commands   â”‚    â”‚ â€¢ REST       â”‚    â”‚ â€¢ Register   â”‚
â”‚ â€¢ Rich UI    â”‚    â”‚ â€¢ Endpoints  â”‚    â”‚ â€¢ Publish    â”‚
â”‚ â€¢ Monitoring â”‚    â”‚ â€¢ Webhooks   â”‚    â”‚ â€¢ Query      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Key Components

1. **Event Bus (Pluggable)** - Message broker for event distribution
   - Currently: Redis Streams
   - Coming: Kafka, RabbitMQ, NATS

2. **Storage (Pluggable)** - Persistent layer for agents, results, metrics
   - Currently: Redis, JSON
   - Coming: PostgreSQL, MongoDB, S3

3. **Agent Runner** - Orchestrates agent execution and lifecycle

4. **CLI** - Beautiful command-line interface (powered by Rich)

5. **API** - RESTful HTTP API (powered by FastAPI)

6. **SDK** - Python SDK for agent integration

---

## ğŸš€ Quick Start

Get OmniDaemon running in **5 minutes**:

```bash
# 1. Install Redis (event bus backend)
docker run -d -p 6379:6379 --name redis redis:latest

# 2. Install OmniDaemon (using uv - recommended)
uv add omnidaemon
# Or with pip: pip install omnidaemon

# 3. Create your first agent
cat > agent_runner.py << 'EOF'
import asyncio
from omnidaemon import OmniDaemonSDK
from omnidaemon import AgentConfig

sdk = OmniDaemonSDK()

async def greeter(message: dict):
    """Your AI agent runs here!"""
    name = message.get("content", {}).get("name", "stranger")
    return {"reply": f"Hello, {name}! ğŸ‘‹"}

async def main():
    await sdk.register_agent(
        agent_config=AgentConfig(
            topic="greet.user",
            callback=greeter,
        )
    )
    await sdk.start()
    print("ğŸ§ Agent running. Press Ctrl+C to stop.")

    try:
        while True:
            await asyncio.sleep(1)
    except KeyboardInterrupt:
        pass
    finally:
        await sdk.shutdown()

if __name__ == "__main__":
    asyncio.run(main())
EOF

# 4. Run your agent
python agent_runner.py
```

**ğŸ‰ Your AI agent is now running and listening for events!**

[**â†’ Continue with Full Tutorial**](getting-started/quick-start.md)

---

## ğŸ“š What's Next?

### For New Users
1. [**Getting Started**](getting-started/introduction.md) - Understand core concepts
2. [**Quick Start Tutorial**](getting-started/quick-start.md) - Build your first agent in 10 minutes
3. [**Complete Examples**](examples/omnicore-agent.md) - Real-world agent implementations

### For Developers
4. [**How-To Guides**](how-to-guides/monitoring.md) - Solve specific problems
5. [**Common Patterns**](how-to-guides/common-patterns.md) - Production-ready recipes
6. [**API Reference**](api-reference/sdk-api.md) - Complete SDK documentation

### For Architects
7. [**Architecture & Design**](architecture/system-overview.md) - Deep dive into system design
8. [**Enterprise**](enterprise/use-cases.md) - Use cases and deployment guide

---

## ğŸŒŸ Learn More

- [**Read the README**](https://github.com/omnirexflora-labs/OmniDaemon) - Comprehensive overview
- [**Explore Examples**](https://github.com/omnirexflora-labs/OmniDaemon/tree/main/examples) - Working code
- [**Join Community**](community/support.md) - Get help and contribute

---

## ğŸ“– References

This documentation is inspired by Sean Falconer's article: ["The Future of AI Agents is Event-Driven"](https://seanfalconer.medium.com/the-future-of-ai-agents-is-event-driven-9e25124060d6)

---

---

## ğŸ‘¨â€ğŸ’» About

**Created by [Abiola Adeshina](https://github.com/Abiorh001) and the OmniDaemon Team**

*From the creators of [OmniCore Agent](https://github.com/omnirexflora-labs/omnicoreagent) â€” building the future of event-driven AI systems*

[â­ Star on GitHub](https://github.com/omnirexflora-labs/OmniDaemon) Â· [ğŸ› Report Bug](https://github.com/omnirexflora-labs/OmniDaemon/issues) Â· [ğŸ’¡ Request Feature](https://github.com/omnirexflora-labs/OmniDaemon/issues)
