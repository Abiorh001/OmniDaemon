# Introduction to OmniDaemon

Welcome to OmniDaemon! This page will help you understand what OmniDaemon is, how it works, and whether it's the right tool for your use case.

---

## What is OmniDaemon?

OmniDaemon is a **universal event-driven runtime engine** specifically designed for AI agents. Think of it as "Kubernetes for AI Agents" - it provides the infrastructure layer that makes AI agents autonomous, observable, and scalable.

### The Simple Explanation

Imagine you have AI agents that need to:
- Run continuously in the background (not just respond to HTTP requests)
- React to events happening across your system
- Work together with other agents
- Process tasks reliably (with retries if something fails)
- Scale up when there's more work to do

OmniDaemon handles all of this infrastructure for you. You just write your AI agent logic, and OmniDaemon takes care of the rest.

---

## Core Concepts (5-Minute Read)

### 1. Event-Driven Architecture

Traditional AI systems work like this:
```
User Request â†’ AI Processes â†’ Response â†’ Done
```

OmniDaemon works like this:
```
Event Published â†’ Agent Reacts â†’ Result Stored
                â†’ Multiple Agents Can Listen
                â†’ Automatic Retries
                â†’ Failed Messages go to DLQ
```

**Why This Matters:**
- Agents run autonomously (don't need someone to ask them)
- Multiple agents can react to the same event
- System is more resilient (failures don't break everything)
- Easy to add new agents without changing existing ones

### 2. Topics and Subscriptions

Agents **subscribe** to **topics** (like email distribution lists):

```python
# Agent registers: "I want to handle 'file.uploaded' events"
await sdk.register_agent(
    agent_config=AgentConfig(
        topic="file.uploaded",  # The topic to listen to
        callback=my_agent,      # The function to run
    )
)
```

When someone **publishes** an event to that topic:

```python
# Publisher sends: "A file was uploaded"
await sdk.publish_task(
    event_envelope=EventEnvelope(
        topic="file.uploaded",
        payload=PayloadBase(
            content={"filename": "document.pdf", "size": 1024}
        ),
    )
)
```

The agent automatically receives and processes it!

### 3. Agent Runners

An **agent runner** is your Python script that:
1. Registers one or more agents
2. Starts listening for events
3. Runs until you stop it (Ctrl+C)

```python
# This is an agent runner
import asyncio
from omnidaemon import OmniDaemonSDK

sdk = OmniDaemonSDK()

async def my_agent(message: dict):
    # Your AI agent logic here
    return {"status": "processed"}

async def main():
    await sdk.register_agent(...)
    await sdk.start()
    
    try:
        while True:
            await asyncio.sleep(1)
    except KeyboardInterrupt:
        pass
    finally:
        await sdk.shutdown()

asyncio.run(main())
```

### 4. The Event Bus

The **event bus** is like a highway for messages. It:
- Delivers events from publishers to agents
- Ensures messages aren't lost
- Handles retries if agents fail
- Load balances across multiple agent instances

Currently, OmniDaemon uses **Redis Streams** as the event bus, but it's pluggable - you can swap in Kafka, RabbitMQ, or NATS in the future (just change an environment variable!).

### 5. Storage

OmniDaemon stores:
- **Agent Registry**: Which agents are registered
- **Results**: Outputs from your agents (kept for 24 hours)
- **Metrics**: How many tasks processed, failed, timing info
- **Configuration**: System settings

Storage is also pluggable - use JSON files for development, Redis for production, or PostgreSQL/MongoDB in the future.

### 6. Consumer Groups

When you run multiple instances of the same agent (for scaling), they form a **consumer group**:

```
Event Published â†’ Event Bus
                    â†“
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â†“          â†“          â†“
    Agent #1   Agent #2   Agent #3
  (Same code)(Same code)(Same code)
```

The event bus automatically distributes work across all instances. Only ONE instance processes each event (no duplication!).

### 7. Dead Letter Queue (DLQ)

If an agent fails repeatedly (default: 3 retries), the message goes to the **DLQ**:

```
Agent Fails â†’ Retry #1 â†’ Fails again â†’ Retry #2 â†’ Fails again â†’ DLQ
```

You can inspect the DLQ to see what went wrong:

```bash
omnidaemon bus dlq --topic file.uploaded
```

---

## When to Use OmniDaemon

### âœ… Great For

**1. Background AI Processing**
```
Example: User uploads document â†’ AI agent extracts text, 
         analyzes sentiment, generates summary
Why: Runs in background, can take minutes, doesn't block user
```

**2. Event-Driven Workflows**
```
Example: Order placed â†’ Payment agent charges card â†’
         Inventory agent reserves items â†’
         Shipping agent schedules delivery
Why: Each step is independent, can be scaled separately
```

**3. Multi-Agent Systems**
```
Example: Research task â†’ Researcher agent gathers info â†’
         Analyzer agent processes data â†’
         Writer agent creates report
Why: Agents collaborate through events, easy to add new agents
```

**4. Long-Running AI Tasks**
```
Example: Train custom model â†’ Evaluate performance â†’
         Deploy if good â†’ Notify team
Why: Task can take hours, needs retry logic, must be reliable
```

**5. Enterprise AI Operations**
```
Example: 100+ agents processing customer support tickets,
         analyzing logs, generating reports
Why: Need observability, scaling, reliability, metrics
```

### âŒ Not Great For

**1. Simple HTTP APIs**
```
Why not: If you just need "request â†’ AI â†’ response",
         use FastAPI directly. Much simpler!
Example: Chat endpoint where user waits for response
```

**2. Real-Time Chat**
```
Why not: Event bus adds latency (~50-100ms).
         Use WebSockets/SSE for real-time chat.
Example: ChatGPT-style interface where user sees tokens streaming
```

**3. Synchronous Request-Response**
```
Why not: If every request needs immediate response,
         REST API is simpler and faster.
Example: "Get user profile" API
```

**4. One-Off Scripts**
```
Why not: If you're running a script once,
         no need for a runtime.
Example: Data migration script
```

---

## How OmniDaemon Compares

| Feature | Celery | AWS Lambda | Temporal | OmniDaemon |
|---------|--------|------------|----------|------------|
| **Purpose** | Task queues | Serverless | Workflows | AI Agents |
| **AI-First** | âŒ No | âŒ No | âŒ No | âœ… Yes |
| **Event-Driven** | âœ… Yes | âš ï¸ Partial | âš ï¸ Partial | âœ… Yes |
| **Setup Complexity** | ğŸ”´ High | ğŸŸ¡ Medium | ğŸ”´ High | ğŸŸ¢ Low |
| **Framework Agnostic** | âœ… Yes | âœ… Yes | âš ï¸ Partial | âœ… Yes |
| **Horizontal Scaling** | âœ… Yes | âœ… Yes | âœ… Yes | âœ… Yes |
| **Agent Abstraction** | âŒ No | âŒ No | âŒ No | âœ… Yes |
| **Pluggable Backends** | âš ï¸ Limited | âŒ No | âŒ No | âœ… Yes |
| **Built-in Metrics** | âš ï¸ Basic | âœ… CloudWatch | âœ… Yes | âœ… Yes |
| **DLQ** | âœ… Yes | âœ… Yes | âœ… Yes | âœ… Yes |
| **Cold Starts** | N/A | ğŸ”´ Yes | N/A | ğŸŸ¢ No |
| **Vendor Lock-in** | ğŸŸ¢ No | ğŸ”´ Yes | âš ï¸ Partial | ğŸŸ¢ No |

---

## System Requirements

### Minimum Requirements

**For Development:**
- Python 3.9 or higher
- 4 GB RAM
- Redis (can run in Docker)

**For Production:**
- Python 3.9 or higher
- 8+ GB RAM (depends on number of agents)
- Redis (recommended: 16+ GB RAM for production)
- Linux (Ubuntu 20.04+, CentOS 7+, or similar)

### Supported Platforms

- âœ… **Linux** (Ubuntu, CentOS, Debian, Fedora, etc.)
- âœ… **macOS** (Intel and Apple Silicon)
- âœ… **Windows** (via WSL2)
- âœ… **Docker** (any platform)

### Event Bus Backends

**Currently Supported:**
- âœ… **Redis Streams** (6.0+)

**Coming Soon:**
- ğŸš§ **Apache Kafka** (2.8+)
- ğŸš§ **RabbitMQ** (3.8+)
- ğŸš§ **NATS JetStream** (2.9+)

### Storage Backends

**Currently Supported:**
- âœ… **JSON** (file-based, for development)
- âœ… **Redis** (6.0+, for production)

**Coming Soon:**
- ğŸš§ **PostgreSQL** (12+)
- ğŸš§ **MongoDB** (4.4+)
- ğŸš§ **Amazon S3** (for results storage)

---

## Architecture Overview

Here's how OmniDaemon fits into your system:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Your Application                      â”‚
â”‚  (Web App, Mobile App, Backend Services, etc.)          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â”‚
                          â”‚ Publishes Events
                          â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     Event Bus                            â”‚
â”‚                  (Redis Streams)                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â”‚
                          â”‚ Delivers Events
                          â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  OmniDaemon Runtime                      â”‚
â”‚                                                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚
â”‚  â”‚  Agent 1   â”‚  â”‚  Agent 2   â”‚  â”‚  Agent 3   â”‚        â”‚
â”‚  â”‚ (OmniCore) â”‚  â”‚(Google ADK)â”‚  â”‚ (LangChain)â”‚        â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚
â”‚                                                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â”‚
                          â”‚ Stores Results
                          â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      Storage                             â”‚
â”‚           (Redis or PostgreSQL or MongoDB)               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## What Makes OmniDaemon Different?

### 1. AI-First Design

OmniDaemon was built specifically for AI agents, not adapted from general task queues.

**This means:**
- First-class support for any AI framework
- Built-in patterns for agent collaboration
- Optimized for long-running AI tasks
- Metrics and observability for AI workloads

### 2. Pluggable Everything

Swap backends without changing code:

```bash
# Development: JSON + Redis
STORAGE_BACKEND=json
EVENT_BUS_TYPE=redis_stream

# Production: PostgreSQL + Kafka  
STORAGE_BACKEND=postgresql
EVENT_BUS_TYPE=kafka
```

No vendor lock-in. Your code stays the same!

### 3. Framework Agnostic

Use ANY AI framework:
- OmniCore Agent
- Google ADK
- LangChain
- AutoGen
- CrewAI
- LlamaIndex
- Or plain Python functions!

```python
# Works with any framework
async def my_agent(message: dict):
    # Use YOUR AI framework here
    result = await your_ai_framework.process(message)
    return result
```

### 4. Production Ready

Built-in:
- âœ… Automatic retries
- âœ… Dead letter queue
- âœ… Metrics tracking
- âœ… Health checks
- âœ… Horizontal scaling
- âœ… Beautiful CLI
- âœ… REST API
- âœ… Graceful shutdown

### 5. Developer Experience

- ğŸ“– Clear documentation (you're reading it!)
- ğŸ¨ Beautiful CLI with Rich
- ğŸ” Easy debugging
- ğŸ“Š Real-time metrics
- ğŸš€ Quick to get started

---

## Next Steps

Ready to dive in?

1. **[Quick Start Tutorial](quick-start.md)** - Build your first agent in 10 minutes
2. **[Core Concepts](../core-concepts/event-driven-architecture.md)** - Deep dive into EDA
3. **[Complete Examples](../examples/omnicore-agent.md)** - See real-world implementations

---

## Questions?

- ğŸ“– [Get Support](../community/support.md)
- ğŸ’¬ [Join Discussions](https://github.com/omnirexflora-labs/OmniDaemon/discussions)
- ğŸ› [Report Issues](https://github.com/omnirexflora-labs/OmniDaemon/issues)
- ğŸ“§ [Contact Support](../community/support.md)

